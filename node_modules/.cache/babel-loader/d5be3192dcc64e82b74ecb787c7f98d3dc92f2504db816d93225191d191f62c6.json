{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.pathToRegexp = exports.tokensToRegexp = exports.regexpToFunction = exports.match = exports.tokensToFunction = exports.compile = exports.parse = void 0;\n/**\n * Tokenize input string.\n */\n\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n  while (i < str.length) {\n    var char = str[i];\n    if (char === '*' || char === '+' || char === '?') {\n      tokens.push({\n        type: 'MODIFIER',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === '\\\\') {\n      tokens.push({\n        type: 'ESCAPED_CHAR',\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === '{') {\n      tokens.push({\n        type: 'OPEN',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === '}') {\n      tokens.push({\n        type: 'CLOSE',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n    if (char === ':') {\n      var name = '';\n      var j = i + 1;\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n        if (\n        // `0-9`\n        code >= 48 && code <= 57 ||\n        // `A-Z`\n        code >= 65 && code <= 90 ||\n        // `a-z`\n        code >= 97 && code <= 122 ||\n        // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n        break;\n      }\n      if (!name) throw new TypeError('Missing parameter name at ' + i);\n      tokens.push({\n        type: 'NAME',\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n    if (char === '(') {\n      var count = 1;\n      var pattern = '';\n      var j = i + 1;\n      if (str[j] === '?') {\n        throw new TypeError('Pattern cannot start with \"?\" at ' + j);\n      }\n      while (j < str.length) {\n        if (str[j] === '\\\\') {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n        if (str[j] === ')') {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === '(') {\n          count++;\n          if (str[j + 1] !== '?') {\n            throw new TypeError('Capturing groups are not allowed at ' + j);\n          }\n        }\n        pattern += str[j++];\n      }\n      if (count) throw new TypeError('Unbalanced pattern at ' + i);\n      if (!pattern) throw new TypeError('Missing pattern at ' + i);\n      tokens.push({\n        type: 'PATTERN',\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n    tokens.push({\n      type: 'CHAR',\n      index: i,\n      value: str[i++]\n    });\n  }\n  tokens.push({\n    type: 'END',\n    index: i,\n    value: ''\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n    prefixes = _a === void 0 ? './' : _a;\n  var defaultPattern = '[^' + escapeString(options.delimiter || '/#?') + ']+?';\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = '';\n  var tryConsume = function tryConsume(type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n  var mustConsume = function mustConsume(type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n      nextType = _a.type,\n      index = _a.index;\n    throw new TypeError('Unexpected ' + nextType + ' at ' + index + ', expected ' + type);\n  };\n  var consumeText = function consumeText() {\n    var result = '';\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume('CHAR') || tryConsume('ESCAPED_CHAR')) {\n      result += value;\n    }\n    return result;\n  };\n  while (i < tokens.length) {\n    var char = tryConsume('CHAR');\n    var name = tryConsume('NAME');\n    var pattern = tryConsume('PATTERN');\n    if (name || pattern) {\n      var prefix = char || '';\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = '';\n      }\n      if (path) {\n        result.push(path);\n        path = '';\n      }\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: '',\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n    var value = char || tryConsume('ESCAPED_CHAR');\n    if (value) {\n      path += value;\n      continue;\n    }\n    if (path) {\n      result.push(path);\n      path = '';\n    }\n    var open = tryConsume('OPEN');\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume('NAME') || '';\n      var pattern_1 = tryConsume('PATTERN') || '';\n      var suffix = consumeText();\n      mustConsume('CLOSE');\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : ''),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n    mustConsume('END');\n  }\n  return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n  var reFlags = flags(options);\n  var _a = options.encode,\n    encode = _a === void 0 ? function (x) {\n      return x;\n    } : _a,\n    _b = options.validate,\n    validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (_typeof(token) === 'object') {\n      return new RegExp('^(?:' + token.pattern + ')$', reFlags);\n    }\n  });\n  return function (data) {\n    var path = '';\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === '?' || token.modifier === '*';\n      var repeat = token.modifier === '*' || token.modifier === '+';\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got an array');\n        }\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n        }\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n          }\n          path += token.prefix + segment + token.suffix;\n        }\n        continue;\n      }\n      if (typeof value === 'string' || typeof value === 'number') {\n        var segment = encode(String(value), token);\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n        }\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n      if (optional) continue;\n      var typeOfMessage = repeat ? 'an array' : 'a string';\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + typeOfMessage);\n    }\n    return path;\n  };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n  var _a = options.decode,\n    decode = _a === void 0 ? function (x) {\n      return x;\n    } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n      index = m.index;\n    var params = Object.create(null);\n    var _loop_1 = function _loop_1(i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return 'continue';\n      var key = keys[i - 1];\n      if (key.modifier === '*' || key.modifier === '+') {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n */\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path; // Use a negative lookahead to match only capturing groups.\n\n  var groups = path.source.match(/\\((?!\\?)/g);\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: '',\n        suffix: '',\n        modifier: '',\n        pattern: ''\n      });\n    }\n  }\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n  var _a = options.strict,\n    strict = _a === void 0 ? false : _a,\n    _b = options.start,\n    start = _b === void 0 ? true : _b,\n    _c = options.end,\n    end = _c === void 0 ? true : _c,\n    _d = options.encode,\n    encode = _d === void 0 ? function (x) {\n      return x;\n    } : _d;\n  var endsWith = '[' + escapeString(options.endsWith || '') + ']|$';\n  var delimiter = '[' + escapeString(options.delimiter || '/#?') + ']';\n  var route = start ? '^' : ''; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n    if (typeof token === 'string') {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n      if (token.pattern) {\n        if (keys) keys.push(token);\n        if (prefix || suffix) {\n          if (token.modifier === '+' || token.modifier === '*') {\n            var mod = token.modifier === '*' ? '?' : '';\n            route += '(?:' + prefix + '((?:' + token.pattern + ')(?:' + suffix + prefix + '(?:' + token.pattern + '))*)' + suffix + ')' + mod;\n          } else {\n            route += '(?:' + prefix + '(' + token.pattern + ')' + suffix + ')' + token.modifier;\n          }\n        } else {\n          route += '(' + token.pattern + ')' + token.modifier;\n        }\n      } else {\n        route += '(?:' + prefix + suffix + ')' + token.modifier;\n      }\n    }\n  }\n  if (end) {\n    if (!strict) route += delimiter + '?';\n    route += !options.endsWith ? '$' : '(?=' + endsWith + ')';\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === 'string' ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 :\n    // tslint:disable-next-line\n    endToken === undefined;\n    if (!strict) {\n      route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n    }\n    if (!isEndDelimited) {\n      route += '(?=' + delimiter + '|' + endsWith + ')';\n    }\n  }\n  return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","pathToRegexp","tokensToRegexp","regexpToFunction","match","tokensToFunction","compile","parse","lexer","str","tokens","i","length","char","push","type","index","name","j","code","charCodeAt","TypeError","count","pattern","options","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","open","name_1","pattern_1","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","String","typeOfMessage","keys","re","decode","pathname","m","exec","params","create","_loop_1","split","replace","sensitive","regexpToRegexp","groups","source","arrayToRegexp","paths","parts","join","stringToRegexp","strict","start","_c","end","_d","endsWith","route","_i","tokens_1","mod","endToken","isEndDelimited"],"sources":["D:/LearnDeveloper/ReactJS/student-management-infor/node_modules/@umijs/route-utils/es/path-to-regexp.js"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.pathToRegexp = exports.tokensToRegexp = exports.regexpToFunction = exports.match = exports.tokensToFunction = exports.compile = exports.parse = void 0;\n/**\n * Tokenize input string.\n */\n\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === '*' || char === '+' || char === '?') {\n      tokens.push({\n        type: 'MODIFIER',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '\\\\') {\n      tokens.push({\n        type: 'ESCAPED_CHAR',\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '{') {\n      tokens.push({\n        type: 'OPEN',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '}') {\n      tokens.push({\n        type: 'CLOSE',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === ':') {\n      var name = '';\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError('Missing parameter name at ' + i);\n      tokens.push({\n        type: 'NAME',\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === '(') {\n      var count = 1;\n      var pattern = '';\n      var j = i + 1;\n\n      if (str[j] === '?') {\n        throw new TypeError('Pattern cannot start with \"?\" at ' + j);\n      }\n\n      while (j < str.length) {\n        if (str[j] === '\\\\') {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === ')') {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === '(') {\n          count++;\n\n          if (str[j + 1] !== '?') {\n            throw new TypeError('Capturing groups are not allowed at ' + j);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError('Unbalanced pattern at ' + i);\n      if (!pattern) throw new TypeError('Missing pattern at ' + i);\n      tokens.push({\n        type: 'PATTERN',\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: 'CHAR',\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: 'END',\n    index: i,\n    value: ''\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? './' : _a;\n  var defaultPattern = '[^' + escapeString(options.delimiter || '/#?') + ']+?';\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = '';\n\n  var tryConsume = function tryConsume(type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function mustConsume(type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError('Unexpected ' + nextType + ' at ' + index + ', expected ' + type);\n  };\n\n  var consumeText = function consumeText() {\n    var result = '';\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume('CHAR') || tryConsume('ESCAPED_CHAR')) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume('CHAR');\n    var name = tryConsume('NAME');\n    var pattern = tryConsume('PATTERN');\n\n    if (name || pattern) {\n      var prefix = char || '';\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = '';\n      }\n\n      if (path) {\n        result.push(path);\n        path = '';\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: '',\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n\n    var value = char || tryConsume('ESCAPED_CHAR');\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = '';\n    }\n\n    var open = tryConsume('OPEN');\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume('NAME') || '';\n      var pattern_1 = tryConsume('PATTERN') || '';\n      var suffix = consumeText();\n      mustConsume('CLOSE');\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : ''),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n\n    mustConsume('END');\n  }\n\n  return result;\n}\n\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (_typeof(token) === 'object') {\n      return new RegExp('^(?:' + token.pattern + ')$', reFlags);\n    }\n  });\n  return function (data) {\n    var path = '';\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === '?' || token.modifier === '*';\n      var repeat = token.modifier === '*' || token.modifier === '+';\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got an array');\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? 'an array' : 'a string';\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + typeOfMessage);\n    }\n\n    return path;\n  };\n}\n\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var _a = options.decode,\n      decode = _a === void 0 ? function (x) {\n    return x;\n  } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n        index = m.index;\n    var params = Object.create(null);\n\n    var _loop_1 = function _loop_1(i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return 'continue';\n      var key = keys[i - 1];\n\n      if (key.modifier === '*' || key.modifier === '+') {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path; // Use a negative lookahead to match only capturing groups.\n\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: '',\n        suffix: '',\n        modifier: '',\n        pattern: ''\n      });\n    }\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d;\n  var endsWith = '[' + escapeString(options.endsWith || '') + ']|$';\n  var delimiter = '[' + escapeString(options.delimiter || '/#?') + ']';\n  var route = start ? '^' : ''; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === 'string') {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === '+' || token.modifier === '*') {\n            var mod = token.modifier === '*' ? '?' : '';\n            route += '(?:' + prefix + '((?:' + token.pattern + ')(?:' + suffix + prefix + '(?:' + token.pattern + '))*)' + suffix + ')' + mod;\n          } else {\n            route += '(?:' + prefix + '(' + token.pattern + ')' + suffix + ')' + token.modifier;\n          }\n        } else {\n          route += '(' + token.pattern + ')' + token.modifier;\n        }\n      } else {\n        route += '(?:' + prefix + suffix + ')' + token.modifier;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += delimiter + '?';\n    route += !options.endsWith ? '$' : '(?=' + endsWith + ')';\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === 'string' ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n    endToken === undefined;\n\n    if (!strict) {\n      route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n    }\n\n    if (!isEndDelimited) {\n      route += '(?=' + delimiter + '|' + endsWith + ')';\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\nexports.pathToRegexp = pathToRegexp;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}